<!DOCTYPE html>
<html>
<head>
    <title>Initialize Pokemon Games</title>
    <style>
        body {
            font-family: monospace;
            background: #000;
            color: #0ff;
            padding: 20px;
        }
        button {
            background: #0ff;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-family: monospace;
            font-weight: bold;
            cursor: pointer;
            margin: 10px 0;
        }
        button:hover {
            background: #00ff88;
        }
        #output {
            margin-top: 20px;
            border: 1px solid #0ff;
            padding: 10px;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>POKEMON GAME DISCOVERY</h1>
    <p>Click the button below to discover and populate Pokemon games from Twitch.</p>

    <button onclick="initializeGames()">INITIALIZE POKEMON GAMES</button>
    <button onclick="testMonitoring()">TEST MONITORING</button>

    <div id="output"></div>

    <script type="module">
        const TWITCH_CLIENT_ID = 'YOUR_TWITCH_CLIENT_ID_HERE';
        const TWITCH_CLIENT_SECRET = 'YOUR_TWITCH_CLIENT_SECRET_HERE';
        const SUPABASE_URL = 'https://uwmriqfxosnaqvvzeiuo.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV3bXJpcWZ4b3NuYXF2dnplaXVvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMxMjI0ODUsImV4cCI6MjA3ODY5ODQ4NX0.LBjXE14R0CK4j-971gkMZqb0bh_0aVY5onLfJx_PZhI';

        const POKEMON_QUERIES = [
            'Pokemon Showdown',
            'Pokemon Scarlet',
            'Pokemon Violet',
            'Pokemon',
        ];

        async function getTwitchToken() {
            const response = await fetch('https://id.twitch.tv/oauth2/token', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    client_id: TWITCH_CLIENT_ID,
                    client_secret: TWITCH_CLIENT_SECRET,
                    grant_type: 'client_credentials',
                }),
            });
            const data = await response.json();
            return data.access_token;
        }

        async function searchTwitchGames(token, query) {
            const response = await fetch(
                `https://api.twitch.tv/helix/search/categories?query=${encodeURIComponent(query)}`,
                {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Client-Id': TWITCH_CLIENT_ID,
                    },
                }
            );
            return await response.json();
        }

        async function saveToSupabase(gameId, gameName) {
            const response = await fetch(`${SUPABASE_URL}/rest/v1/pokemon_game_ids`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                    'Prefer': 'resolution=merge-duplicates',
                },
                body: JSON.stringify({
                    game_id: gameId,
                    game_name: gameName,
                    is_active: true,
                }),
            });
            return response;
        }

        window.initializeGames = async function() {
            const output = document.getElementById('output');
            output.textContent = '> Initializing...\n';

            try {
                output.textContent += '> Getting Twitch access token...\n';
                const token = await getTwitchToken();
                output.textContent += '> Token obtained successfully\n\n';

                const discoveredGames = new Map();

                for (const query of POKEMON_QUERIES) {
                    output.textContent += `> Searching for: ${query}\n`;
                    const result = await searchTwitchGames(token, query);

                    if (result.data) {
                        for (const game of result.data) {
                            if (game.name.toLowerCase().includes('pokemon') ||
                                game.name.toLowerCase().includes('pokémon')) {
                                if (!discoveredGames.has(game.id)) {
                                    discoveredGames.set(game.id, game.name);
                                    output.textContent += `  Found: ${game.name} (ID: ${game.id})\n`;
                                }
                            }
                        }
                    }
                }

                output.textContent += `\n> Total games found: ${discoveredGames.size}\n\n`;
                output.textContent += '> Saving to database...\n';

                for (const [gameId, gameName] of discoveredGames) {
                    await saveToSupabase(gameId, gameName);
                    output.textContent += `  Saved: ${gameName}\n`;
                }

                output.textContent += '\n> ✓ INITIALIZATION COMPLETE\n';
                output.textContent += `> ${discoveredGames.size} Pokemon games are now being monitored\n`;
            } catch (error) {
                output.textContent += `\n> ERROR: ${error.message}\n`;
                console.error(error);
            }
        };

        window.testMonitoring = async function() {
            const output = document.getElementById('output');
            output.textContent = '> Testing monitoring endpoint...\n';

            try {
                const response = await fetch(
                    `${SUPABASE_URL}/functions/v1/pokemon-battle-oracle?action=monitor`,
                    {
                        headers: {
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        },
                    }
                );
                const data = await response.json();
                output.textContent += '\n> Response:\n';
                output.textContent += JSON.stringify(data, null, 2);
            } catch (error) {
                output.textContent += `\n> ERROR: ${error.message}\n`;
            }
        };
    </script>
</body>
</html>
